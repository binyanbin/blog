<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 码工严彬 coding不仅仅是工作</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/2015/12/20/self-introduce/" target="_self" class="nav-list-link">WECHAT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/06/english-1/" class="post-title-link">英语入门视频推荐</a></h2><div class="post-meta"><div class="post-time">2016年5月6日</div></div><div class="post-content"><p>坚持学习英语也有一年多时间，除了在线外教学习，还看一些原版英语课程和英语电视剧，下面我分享2个非常非常非常合适初学者的系列视频’Learn English with Jennifer’和’extro English’。<br></div><a href="2016/05/06/english-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/02/CSharp-2/" class="post-title-link">C#由内存模型说性能2 数组与集合</a></h2><div class="post-meta"><div class="post-time">2016年5月2日</div></div><div class="post-content"><p>由于.net不会实时回收内存，那么.net对数组与集合是内存的是怎么处理的</p>
<h2 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h2><p>大家都知道数组必须指定大小，而且大小一但指定就不能更改了，也就是说数组不能动态的增加容量，那么对于一些需要动态增加容量的需求是实现不了的。实现动态扩容的需求都是通过集合,如List,Dictionary,ArrayList.<br></div><a href="2016/05/02/CSharp-2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/30/CSharp-1/" class="post-title-link">.net由内存模型说性能1</a></h2><div class="post-meta"><div class="post-time">2016年4月30日</div></div><div class="post-content"><p>.net不必手工管理内存，但要编写高性能的代码，就仍需理解后面发生的事情。</p>
<h2 id="内存模型-堆与栈"><a href="#内存模型-堆与栈" class="headerlink" title="内存模型:堆与栈"></a>内存模型:堆与栈</h2><p>C#内存主要有两类：Stack和Heap<br>Stack叫做栈区，由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>Heap则称之为堆区，由开发人员申请内存，在垃圾回收器的控制下工作。<br><img src="/img/CSharp-1.jpg" alt="效果"></p></div><a href="2016/04/30/CSharp-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/21/hishop-1/" class="post-title-link">浅谈Himall商城限时购设计</a></h2><div class="post-meta"><div class="post-time">2016年4月21日</div></div><div class="post-content"><p>互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。<a href="http://www.hishop.com.cn/products/himall/">Himall</a>限时购功能则是一个典型的短时间高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。<br>什么是限时购?限时购跟大部分电商抢购业务相同,即限时且限量抢购。不管小米还是华为，或是其它电商公司，对抢购业务运营总是最为火爆，每发一款新品，都限量发售，每次搞的大家心里痒痒的。抢购太火爆有时引起站点打不开，崩溃了;还有就是卖出的数量比设置可购买的数量要多。那么问题来了：我们如何在设计中如何解决。通常我们需要从设计中考虑以下问题:</p>
<ul>
<li>针对高并发，我们如何解耦后端压力，特别是数据库的压力。</li>
<li>如何保障库存可靠。</div><a href="2016/04/21/hishop-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/17/c-7/" class="post-title-link">C windows版开源http服务</a></h2><div class="post-meta"><div class="post-time">2016年4月17日</div></div><div class="post-content"></div><a href="2016/04/17/c-7/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/13/c-6/" class="post-title-link">C语言之socket 简易客户端</a></h2><div class="post-meta"><div class="post-time">2016年4月13日</div></div><div class="post-content"><p>昨天做了一个简易服务端，今天尝试做一个简易客户端，东西比较少，很顺利就完成了。客户端socket操作步骤:1.创建socket 2.连接服务端 3.接收服务端返回数据</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>1.连接:<br>int connect(int fd, const struct sockaddr* addr, socklen_t address_len));<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>address_len：确定address缓冲区的长度<br>返回值：如果函数执行成功，返回值为0，否则为-1。</p>
<p>2.接收<br>int recv(SOCKET socket, char FAR* buf, int len, int flags);<br>socket：一个标识已连接套接口的描述字。<br>buf：用于接收数据的缓冲区。<br>len：缓冲区长度。<br>flags：指定调用方式。<br>返回值：若无错误发生,recv()返回读入的字节数.如果连接已中止，返回0.否则的话,返回SOCKET_ERROR错误.</p></div><a href="2016/04/13/c-6/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/12/c-5/" class="post-title-link">C语言之socket 简易服务端</a></h2><div class="post-meta"><div class="post-time">2016年4月12日</div></div><div class="post-content"><p>今年有两个目标，一个是做开源项目，第二个是用C写一个网络服务。C写网络服务Socket是基础，首先需要了解socket的用法。服务端socket操作步骤:1.创建socket,2.绑定地址及端口,3.接收请求,4.发送数据。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>1.创建socket:<br>int socket(int domain, int type, int protocol);<br>domain：协议域<br>type：指定Socket类型。<br>protocol：指定协议。<br>返回值：如果调用成功就返回新创建的套接字的描述符，如果失败就返回-1。</p>
<p>2.绑定地址级端口<br>int bind(SOCKET socket, const struct sockaddr* address, socklen_t address_len);<br>参数说明：<br>socket：是一个套接字描述符。<br>address：是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。<br>address_len：确定address缓冲区的长度。<br>返回值：如果函数执行成功，返回值为0，否则为SOCKET_ERROR。</p>
<p>3.接收连接请求<br>int accept( int fd, struct socketaddr<em> addr, socklen_t</em> len);<br>参数说明：<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>len：接收返回地址的缓冲区长度<br>返回值：成功返回客户端的文件描述符，失败返回-1。</p>
<p>4.发送数据<br>int send(int fd, const void * msg, int len, unsigned int falgs);<br>fd：套接字描述符。<br>msg: 数据内容。<br>len: 数据长度。<br>返回值：成功则返回实际传送出去的字符数, 失败返回-1.</p></div><a href="2016/04/12/c-5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/31/c-4/" class="post-title-link">C语言之函数库</a></h2><div class="post-meta"><div class="post-time">2016年3月31日</div></div><div class="post-content"></div><a href="2016/03/31/c-4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/25/c-3/" class="post-title-link">C语言之由内存模型说起</a></h2><div class="post-meta"><div class="post-time">2016年3月25日</div></div><div class="post-content"><p>说起内存模型，那就先要介绍程序运行时是如何管理内存的。<br>程序运行时:</p>
<ul>
<li>系统先把物理硬盘代码load到内存</li>
<li>系统再把c代码分成四个区</li>
<li>系统再找到main函数入口执行<h2 id="程序的四区模型"><a href="#程序的四区模型" class="headerlink" title="程序的四区模型"></a>程序的四区模型</h2><img src="/img/c-3.png" alt="效果"></div><a href="2016/03/25/c-3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/24/c-2/" class="post-title-link">C语言之个性化termial</a></h2><div class="post-meta"><div class="post-time">2016年3月24日</div></div><div class="post-content"><p>很多牛人有自己的个性化的命令行，为什么我没有呢?晚上我就写了一个。效果如下:<br><img src="/img/c-1.png" alt="效果"><br></div><a href="2016/03/24/c-2/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/" class="prev">上一页</a><a href="/page/3/" class="next">下一页</a></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?fcf7e8f303b6e03be86f5619636d0f7e";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>