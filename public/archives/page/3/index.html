<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 码工严彬 coding不仅仅是工作</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/binyanbin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2015/12/20/self-introduce/" target="_self" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/10/redis-8/" class="post-title-link">redis学习8  Sentinel集群控制</a></h2><div class="post-meta"><div class="post-time">2016年3月10日</div></div><div class="post-content"><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br></div><a href="2016/03/10/redis-8/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/09/redis-7/" class="post-title-link">redis学习7 主从复制</a></h2><div class="post-meta"><div class="post-time">2016年3月9日</div></div><div class="post-content"><p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。</div><a href="2016/03/09/redis-7/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/08/redis-6/" class="post-title-link">redis学习6 持久化</a></h2><div class="post-meta"><div class="post-time">2016年3月8日</div></div><div class="post-content"><p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br></div><a href="2016/03/08/redis-6/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/07/redis-5/" class="post-title-link">redis学习5 lua脚本</a></h2><div class="post-meta"><div class="post-time">2016年3月7日</div></div><div class="post-content"><p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。</div><a href="2016/03/07/redis-5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/05/redis-4/" class="post-title-link">redis学习4 事务</a></h2><div class="post-meta"><div class="post-time">2016年3月5日</div></div><div class="post-content"><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</div><a href="2016/03/05/redis-4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/03/redis-3/" class="post-title-link">redis学习3 数据类型</a></h2><div class="post-meta"><div class="post-time">2016年3月3日</div></div><div class="post-content"><p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets</div><a href="2016/03/03/redis-3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/02/redis-2/" class="post-title-link">redis学习2 Pub/Sub</a></h2><div class="post-meta"><div class="post-time">2016年3月2日</div></div><div class="post-content"><p>Pub/Sub功能（means Publish,Subscribe）即发布及订阅功能.在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这让我想到了一种模式:观察者模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某一发布者（主题对象或目标对象），在发布者的状态发生变化时，会通知所有观察者对象。<br>常见的应用场景:构建实时消息系统，比如普通的即时聊天，群聊等功能。消息队列功能.<br></div><a href="2016/03/02/redis-2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/28/redis-1/" class="post-title-link">redis学习1 环境及配置</a></h2><div class="post-meta"><div class="post-time">2016年2月28日</div></div><div class="post-content"><p>最近工作需要使用redis，现在只能边学习边总结。Redis的介绍就不说了，网上一搜一大把。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方不提供windows版redis，<a href="https://github.com/MSOpenTech">微软开源技术的github</a>上有提供，可以<a href="https://github.com/MSOpenTech/redis/releases">下载</a>。下载解决之后，我们就开始可以搭建开发环境。<br></div><a href="2016/02/28/redis-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/26/lock/" class="post-title-link">并发情况下锁的使用</a></h2><div class="post-meta"><div class="post-time">2016年2月26日</div></div><div class="post-content"><p>在<a href="http://binyanbin.github.io/2016/02/18/interview-hishop/">电商面试题</a>中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。<br></div><a href="2016/02/26/lock/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/23/8year-review/" class="post-title-link">一家公司的8年技术总结</a></h2><div class="post-meta"><div class="post-time">2016年2月23日</div></div><div class="post-content"></div><a href="2016/02/23/8year-review/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/archives/page/2/" class="prev">上一页</a><a href="/archives/page/4/" class="next">下一页</a></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?fcf7e8f303b6e03be86f5619636d0f7e";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>