---
title: 并发情况下锁的使用
date: 2016-2-26
desc: 缓存 锁
---
在[电商面试题](http://binyanbin.github.io/2016/02/18/interview-hishop/)中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。
<!-- more -->
# 读写锁
缓存一般使用的情况应该是:
* 只能由一个线程写，但可以多个线程读。
* 在读操作时，不能同时让其它线程写，在写操作时，不能同时读。

实现以上两种情况的锁称读写锁，读写锁有两种模式。
* 读模式:可以有多个线程同时占有。
* 写模式:一次只有一个线程可以占有。

# 互斥锁
在我面试题的代码中所有操作使用的是互斥锁，即保证lock上的代码同一时刻只被一个线程操作。这么做可以保证在任意时刻只有单个线程访问缓存，做到线程安全，但是这种方式效率并不高。原因如下:
* 降低读的并发性，降低了系统使用效率。
* 像限时抢购、秒杀这种高并发场景，应该要支持对不同的抢购商品并发下单，提高下单效率。

# 限时抢购、秒杀并发场景的应用
1.应为每个商品订单缓存建一个读写锁。
2.在对商品下单时，应该对该商品加上写模式锁，保证该商品同一时刻只有一个用户下单，不会引起商品超卖。
3.获取订单缓存数据时，应为该商品加上读模式锁，保证其它线程也可以读到缓存订单数据。




